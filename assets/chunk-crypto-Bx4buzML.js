async function u(o,r){const n=new TextEncoder().encode(o),c=await crypto.subtle.importKey("raw",n,"PBKDF2",!1,["deriveBits","deriveKey"]);return await crypto.subtle.deriveKey({name:"PBKDF2",salt:r,iterations:1e5,hash:"SHA-256"},c,{name:"AES-GCM",length:256},!1,["decrypt"])}function g(o){o=o.replace(/\s/g,"");try{const r=atob(o),t=new Uint8Array(r.length);for(let n=0;n<r.length;n++)t[n]=r.charCodeAt(n);return t}catch(r){console.warn("atob() 失败，尝试使用备用方法:",r);try{const t=`data:application/octet-stream;base64,${o}`,n=new XMLHttpRequest;n.open("GET",t,!1),n.overrideMimeType("text/plain; charset=x-user-defined"),n.send();const c=n.responseText,a=new Uint8Array(c.length);for(let e=0;e<c.length;e++)a[e]=c.charCodeAt(e)&255;return a}catch(t){return console.error("备用方法也失败:",t),w(o)}}}function w(o){const r="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",t=new Uint8Array(256);for(let e=0;e<r.length;e++)t[r.charCodeAt(e)]=e;let n=o.length*.75;o[o.length-1]==="="&&(n--,o[o.length-2]==="="&&n--);const c=new Uint8Array(n);let a=0;for(let e=0;e<o.length;e+=4){const l=t[o.charCodeAt(e)],s=t[o.charCodeAt(e+1)],d=t[o.charCodeAt(e+2)],i=t[o.charCodeAt(e+3)];c[a++]=l<<2|s>>4,c[a++]=(s&15)<<4|d>>2,c[a++]=(d&3)<<6|i&63}return c}async function m(o,r){try{console.log("[Crypto] 开始解密，原始内容长度:",o.length);const t=o.replace(/\r\n/g,`
`).replace(/\r/g,`
`),n=/^---\n([\s\S]*?)\n---\n/,c=t.match(n);let a="",e=t;if(c?(a=c[0],e=t.substring(c[0].length),console.log("[Crypto] 已提取 metadata，剩余内容长度:",e.length)):console.warn("[Crypto] 未能提取 metadata，将处理整个内容"),e=e.replace(/<!--\s*ENCRYPTED\s*CONTENT\s*-->/gi,""),e=e.replace(/[^A-Za-z0-9+/=]/g,""),console.log("[Crypto] 清理后的 Base64 字符串长度:",e.length),console.log("[Crypto] Base64 前50个字符:",e.substring(0,50)),!e||e.length<40)throw new Error("加密数据为空或过短");const l=g(e);if(console.log("[Crypto] 解码后的字节数组长度:",l.length),l.length<28)throw new Error(`加密数据格式无效，长度仅 ${l.length} 字节，需要至少 28 字节`);const s=l.slice(0,16),d=l.slice(16,28),i=l.slice(28);console.log("[Crypto] Salt:",Array.from(s.slice(0,4)).map(h=>h.toString(16).padStart(2,"0")).join("")),console.log("[Crypto] Nonce:",Array.from(d.slice(0,4)).map(h=>h.toString(16).padStart(2,"0")).join("")),console.log("[Crypto] Ciphertext 长度:",i.length);const y=await u(r,s),p=await crypto.subtle.decrypt({name:"AES-GCM",iv:d,tagLength:128},y,i),f=new TextDecoder("utf-8").decode(p);return a+f}catch(t){throw console.error("解密错误:",t),t.name==="OperationError"?new Error("密码错误或文件已损坏 (authentication failed)"):t}}function x(o,r,t){return t[r]?t[r].includes(o):!1}export{m as d,x as i};
