async function u(t,r){const n=new TextEncoder().encode(t),o=await crypto.subtle.importKey("raw",n,"PBKDF2",!1,["deriveBits","deriveKey"]);return await crypto.subtle.deriveKey({name:"PBKDF2",salt:r,iterations:1e5,hash:"SHA-256"},o,{name:"AES-GCM",length:256},!1,["decrypt"])}function h(t){t=t.replace(/\s/g,"");const r=atob(t),e=new Uint8Array(r.length);for(let n=0;n<r.length;n++)e[n]=r.charCodeAt(n);return e}async function E(t,r){try{const e=/^---\n([\s\S]*?)\n---\n/,n=t.match(e);let o="",c=t;n&&(o=n[0],c=t.substring(n[0].length)),c=c.replace(`<!-- ENCRYPTED CONTENT -->
`,"").replace(/\s/g,"");const a=h(c);if(a.length<28)throw new Error("加密数据格式无效");const s=a.slice(0,16),i=a.slice(16,28),d=a.slice(28),l=await u(r,s),y=await crypto.subtle.decrypt({name:"AES-GCM",iv:i,tagLength:128},l,d),f=new TextDecoder("utf-8").decode(y);return o+f}catch(e){throw console.error("解密错误:",e),e.name==="OperationError"?new Error("密码错误或文件已损坏 (authentication failed)"):e}}function m(t,r,e){return e[r]?e[r].includes(t):!1}export{E as d,m as i};
