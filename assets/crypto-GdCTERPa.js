async function h(t,r){const n=new TextEncoder().encode(t),o=await crypto.subtle.importKey("raw",n,"PBKDF2",!1,["deriveBits","deriveKey"]);return await crypto.subtle.deriveKey({name:"PBKDF2",salt:r,iterations:1e5,hash:"SHA-256"},o,{name:"AES-GCM",length:256},!1,["decrypt"])}async function m(t,r){try{const e=/^---\n([\s\S]*?)\n---\n/,n=t.match(e);let o="",c=t;n&&(o=n[0],c=t.substring(n[0].length)),c=c.replace(`<!-- ENCRYPTED CONTENT -->
`,"").trim();const a=Uint8Array.from(atob(c),u=>u.charCodeAt(0));if(a.length<28)throw new Error("加密数据格式无效");const s=a.slice(0,16),i=a.slice(16,28),d=a.slice(28),l=await h(r,s),y=await crypto.subtle.decrypt({name:"AES-GCM",iv:i,tagLength:128},l,d),f=new TextDecoder("utf-8").decode(y);return o+f}catch(e){throw console.error("解密错误:",e),e.name==="OperationError"?new Error("密码错误或文件已损坏 (authentication failed)"):e}}function E(t,r,e){return e[r]?e[r].includes(t):!1}export{m as d,E as i};
