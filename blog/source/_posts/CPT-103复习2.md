---
title: CPT-103复习2
date: 2023-05-09 21:27:15
tags:
- XJTLU
- 笔记
- 数据库
categories:
 - 中文推文
 - 学习
 - 数据库
---
上期过于繁琐，导致文章的冗长。这次仅记录想到的。

<!--more-->

# Lec2

1. ## Foreign Key
	1. 外键是一种约束，遵循约束的格式。
	2. 基本语法
		```Sql
		CONSTRAINT name
			FOREIGN KEY
				(col1, col2, ...)
			REFERENCES
			tablename
				(col1, col2, ...)
			[ON UPDATE ref_opt
			ON DELETE ref_opt]

		ref_opt: RESTRICT | CASCADE | SET NULL | SET DEFAULT
		```
	3. 在应用外键后，被关联的列会被数据库检查数据，他的值将会变成关联的列中的值或者NULL。
	4. ref_opt指的是在被关联的主表中进行UPDATE\DELETE操作时，子表将会进行的操作。
		1. `RESTRICT`: 默认选项，只有之表没有相关记录时，主表的记录才可以被操作
		2. `CASCADE`: 当主表的记录变动，子表的记录也会变动。主表中进行删除操作，子表相关记录会被整行删除
		3. `SET NULL\DEFAULT`: 在主表进行操作后，子表自动设置更新值
2. ## BINARY
	1. 一般的SQL语句是不区分大小写的。
		例如，但xx的第一列是Primary Key时
		```Sql
		INSERT INTO xx VALUES
		('B001'),
		('b001');
		```
		**'B001'** 和 **'b001'** 会冲突，导致第二行无法被加入。
		这时候需要在创建表的时候为此列添加`BINARY`关键字
		```Sql
		CREATE TABLE `branch` (
			`branchNo` CHAR(4) BINARY NOT NULL,
			PRIMARY KEY (`branchNo`),
			...);
		```
		这样，其便能将大小写的String分为不同的对象。
3.  ## ALTER
	```Sql
	新增列
	ALTER TABLE tablename
		ADD colname 
			datatype [options like UNIQUE ...];
	
	删除列
	ALTER TABLE tablename
		DROP COLUMN colname;
	
	修改列名称和定义
	ALTER TABLE tablename
		CHANGE COLUMN colname
			newcolname datatype [options];
	
	仅修改列定义
	ALTER TABLE tablename
		MODIFY COLUMN colname
			datatype [options];
	
	新增约束
	ALTER TABLE tablename
		ADD CONSTRAINT name definition;
	
	删除约束
	ALTER TABLE tablename
		DROP INDEX name | DROP FOREIGN KEY name | DROP PRIMARY KEY name
	```
4. ## DROP
	
	语法
	```Sql
	DROP TABLE [IF EXISTS] tablename1, tablename2,...;
	```

# Lec3
SELECT的部分内容

1. ## SELECT的语法
	```Sql
	SELECT [DISTINCT | ALL]
		colnames FROM tablenames
		[WHERE condition]
		[ORDER BY colnames [ASC | DESC]]
		[GROUP BY colname]
		[HAVING condition]
	```
- DISTINCT 会去重。例如Last列为{1,1,2,1,3,2,4}直接SELECT\ALL会返回{1,1,2,1,3,2,4}而DISTINCT 会返回{1,2,3,4}
2. ## WHERE 的 condition
	- condition 中可以使用LIKE关键字来进行文字匹配。'%'通配符表示任意多的字符，'\_'通配符表示任一字符
	- EXIST(t)在表t中有记录时返回true，无则返回false
	- ANY/ALL用于一组判断条件中。ANY表示子记录中有一项满足条件即返回true；ALL这表示子记录必须全部满足条件才可返回true

# Lec4
1. ## Joins
	Join置于FROM中，基本语法为
	```Sql
	SELECT * FROM A XXX JOIN B;
	```
	1. ### CROSS JOIN
		CROSS JOIN的效果与同时查询两个表相同
		```Sql
		SELECT * FROM A CROSS JOIN B;
		as same as 
		SELECT * FROM A, B;
		```
	1. ### INNER JOIN
		```Sql
		SELECT colnames FROM A INNER JOIN B ON conditions;
		or
		SELECT colnames FROM A INNER JOIN B USING (col1, col2, ...);
		```
		USING后跟随的col必须是两个表共有的，之后根据两个表中col的值来判断显示。仅同时在两个表中出现的值的行会出现在查询中。
		表B会跟随在表A右边，并且有且仅有满足条件的行会出现。
	1. ### NATURAL JOIN
	NATURAN JOIN会将两表中以相同名称的列进行联结。
	若两表中都有列ID，则NATURAL JOIN的效果与INNER JOIN USING(ID)相同。
	1. ### OUTER JOIN
		```Sql
		SELECT cols FROM 
			tablename type OUTER JOIN tablename2 
			ON condition;
		type = LEFT | RIGHT | FULL
		```
		1. #### LEFT
			LEFT OUTER JOIN联结的两表，会以前表为基准，后表联结在前表右边，后表中不符合condition的行将会置NULL
		2. #### RIGHT
			与LEFT相似，但部分相反。以后表为基准，后表仍然联结在前表右边，前表中不符合condition的行将会置NULL
		3. #### FULL
			两表都是基准，前后表都满足条件的行互相接壤，而有不满足条件的则置NULL。后表仍然联结在前表右边。
2. ## GROUP BY 和 HAVING
	1. GROUPBY用作选择一个列的内容作为分类基准，将其他列的内容进行汇总后呈现为行数为类数的单张表。在进行GROUPBY的操作时，SELECT中除被选择作为分类基准的所有列都必须是可汇总的。
	2. HVING一般接在GROUPBY后面，用作过滤结果。
	3. ### HAVING和WHERE的区别。
		1. HAVING中可以使用聚合函数，而WHERE不行。
		2. WHERE是约束语句，用在返回结果之前，约束数据库中返回结果的条件。
		3. HVING是过滤语句，用在返回结果之后，对其使用聚合函数进行更进一步的过滤。

# Lec5
1. ## SET operations
	用以连接多个SELECT。
	1. ### UNION
		A UNION B将会返回A和B的所有信息
	1. ### INTERSECT
		A INTERSECT B将会返回A和B重合部分的信息
	1. ### EXCEPT
		A EXCEPT B将会返回A去除掉与B重合部分的信息
2. ## 丢失数据的处理
	1. ### NULL
		1. NULL作任何算数操作仍然是NULL
		2. NULL在GROUP BY中仍然可用。
	2. ### DEFAULT value
		1. 以默认数替代NULL，以达到都可以被处理的效果。